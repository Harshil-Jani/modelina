import { isReservedCppKeyword } from '../../../src/generators/cpp/Constants';

describe('Reserved keywords', () => {
  it('shoud return true if the word is a reserved keyword', () => {
    expect(isReservedCppKeyword('alignas')).toBe(true);
    expect(isReservedCppKeyword('alignof')).toBe(true);
    expect(isReservedCppKeyword('and')).toBe(true);
    expect(isReservedCppKeyword('and_eq')).toBe(true);
    expect(isReservedCppKeyword('asm')).toBe(true);
    expect(isReservedCppKeyword('auto')).toBe(true);
    expect(isReservedCppKeyword('bitand')).toBe(true);
    expect(isReservedCppKeyword('bitor')).toBe(true);
    expect(isReservedCppKeyword('bool')).toBe(true);
    expect(isReservedCppKeyword('break')).toBe(true);
    expect(isReservedCppKeyword('case')).toBe(true);
    expect(isReservedCppKeyword('catch')).toBe(true);
    expect(isReservedCppKeyword('char')).toBe(true);
    expect(isReservedCppKeyword('char16_t')).toBe(true);
    expect(isReservedCppKeyword('char32_t')).toBe(true);
    expect(isReservedCppKeyword('class')).toBe(true);
    expect(isReservedCppKeyword('compl')).toBe(true);
    expect(isReservedCppKeyword('const')).toBe(true);
    expect(isReservedCppKeyword('constexpr')).toBe(true);
    expect(isReservedCppKeyword('const_cast')).toBe(true);
    expect(isReservedCppKeyword('continue')).toBe(true);
    expect(isReservedCppKeyword('decltype')).toBe(true);
    expect(isReservedCppKeyword('default')).toBe(true);
    expect(isReservedCppKeyword('delete')).toBe(true);
    expect(isReservedCppKeyword('do')).toBe(true);
    expect(isReservedCppKeyword('double')).toBe(true);
    expect(isReservedCppKeyword('dynamic_cast')).toBe(true);
    expect(isReservedCppKeyword('else')).toBe(true);
    expect(isReservedCppKeyword('enum')).toBe(true);
    expect(isReservedCppKeyword('explicit')).toBe(true);
    expect(isReservedCppKeyword('export')).toBe(true);
    expect(isReservedCppKeyword('extern')).toBe(true);
    expect(isReservedCppKeyword('false')).toBe(true);
    expect(isReservedCppKeyword('float')).toBe(true);
    expect(isReservedCppKeyword('for')).toBe(true);
    expect(isReservedCppKeyword('friend')).toBe(true);
    expect(isReservedCppKeyword('goto')).toBe(true);
    expect(isReservedCppKeyword('if')).toBe(true);
    expect(isReservedCppKeyword('inline')).toBe(true);
    expect(isReservedCppKeyword('int')).toBe(true);
    expect(isReservedCppKeyword('long')).toBe(true);
    expect(isReservedCppKeyword('mutable')).toBe(true);
    expect(isReservedCppKeyword('namespace')).toBe(true);
    expect(isReservedCppKeyword('new')).toBe(true);
    expect(isReservedCppKeyword('noexcept')).toBe(true);
    expect(isReservedCppKeyword('not')).toBe(true);
    expect(isReservedCppKeyword('not_eq')).toBe(true);
    expect(isReservedCppKeyword('nullptr')).toBe(true);
    expect(isReservedCppKeyword('operator')).toBe(true);
    expect(isReservedCppKeyword('or')).toBe(true);
    expect(isReservedCppKeyword('or_eq')).toBe(true);
    expect(isReservedCppKeyword('private')).toBe(true);
    expect(isReservedCppKeyword('protected')).toBe(true);
    expect(isReservedCppKeyword('public')).toBe(true);
    expect(isReservedCppKeyword('register')).toBe(true);
    expect(isReservedCppKeyword('reinterpret_cast')).toBe(true);
    expect(isReservedCppKeyword('return')).toBe(true);
    expect(isReservedCppKeyword('short')).toBe(true);
    expect(isReservedCppKeyword('signed')).toBe(true);
    expect(isReservedCppKeyword('sizeof')).toBe(true);
    expect(isReservedCppKeyword('static')).toBe(true);
    expect(isReservedCppKeyword('static_assert')).toBe(true);
    expect(isReservedCppKeyword('static_cast')).toBe(true);
    expect(isReservedCppKeyword('struct')).toBe(true);
    expect(isReservedCppKeyword('switch')).toBe(true);
    expect(isReservedCppKeyword('template')).toBe(true);
    expect(isReservedCppKeyword('this')).toBe(true);
    expect(isReservedCppKeyword('thread_local')).toBe(true);
    expect(isReservedCppKeyword('throw')).toBe(true);
    expect(isReservedCppKeyword('true')).toBe(true);
    expect(isReservedCppKeyword('try')).toBe(true);
    expect(isReservedCppKeyword('typedef')).toBe(true);
    expect(isReservedCppKeyword('typeid')).toBe(true);
    expect(isReservedCppKeyword('typename')).toBe(true);
    expect(isReservedCppKeyword('union')).toBe(true);
    expect(isReservedCppKeyword('unsigned')).toBe(true);
    expect(isReservedCppKeyword('using')).toBe(true);
    expect(isReservedCppKeyword('virtual')).toBe(true);
    expect(isReservedCppKeyword('void')).toBe(true);
    expect(isReservedCppKeyword('volatile')).toBe(true);
    expect(isReservedCppKeyword('wchar_t')).toBe(true);
    expect(isReservedCppKeyword('while')).toBe(true);
    expect(isReservedCppKeyword('xor')).toBe(true);
    expect(isReservedCppKeyword('xor_eq')).toBe(true);
  });

  it('should return false if the word is not a reserved keyword', () => {
    expect(isReservedCppKeyword('dinosaur')).toBe(false);
  });
});
